// Code generated
// This file is a generated precompile contract config with stubbed abstract functions.
// The file is generated by a template. Please inspect every code and comment in this file before use.

package bls

import (
	"fmt"
	"log"

	"github.com/ava-labs/subnet-evm/precompile/contract"
	"github.com/ava-labs/avalanchego/utils/crypto/bls"

	_ "embed"

	"github.com/ethereum/go-ethereum/common"
)

const (
	// Gas cost for verifying a BLS signature
	VerifySignatureGasCost uint64 = 50000
)

var (
	// ABI definition for the BLS verification contract
	//go:embed contract.abi
	BlsVerificationRawABI string

	// Parsed ABI for encoding/decoding
	BlsVerificationABI = contract.ParseABI(BlsVerificationRawABI)

	// Contract instance
	BlsVerificationPrecompile = createBlsVerificationPrecompile()
)

// Input structure for verifySignature
type VerifySignatureInput struct {
	Signature []byte
	PublicKey []byte
	Message   []byte
}

// Decode input data for verifySignature
func UnpackVerifySignatureInput(input []byte) (VerifySignatureInput, error) {
	var inputStruct VerifySignatureInput
	err := BlsVerificationABI.UnpackInputIntoInterface(&inputStruct, "verifySignature", input, false)
	return inputStruct, err
}

// Encode output data for verifySignature
func PackVerifySignatureOutput(isValid bool) ([]byte, error) {
	return BlsVerificationABI.PackOutput("verifySignature", isValid)
}

// Main function for verifying a BLS signature
func verifySignature(
	_ contract.AccessibleState,
	_ common.Address,
	_ common.Address,
	input []byte,
	suppliedGas uint64,
	_ bool,
) ([]byte, uint64, error) {
	remainingGas, err := contract.DeductGas(suppliedGas, VerifySignatureGasCost)
	if err != nil {
		log.Printf("Gas deduction failed: %v", err)
		return nil, 0, err
	}

	// Parse input
	inputStruct, err := UnpackVerifySignatureInput(input)
	if err != nil {
		log.Printf("Failed to unpack input: %v", err)
		return nil, remainingGas, fmt.Errorf("failed to unpack input: %w", err)
	}

	// Debug logs
	log.Printf("Signature: %x", inputStruct.Signature)
	log.Printf("Public Key: %x", inputStruct.PublicKey)
	log.Printf("Message: %x", inputStruct.Message)

	// Parse public key
	publicKey, err := bls.PublicKeyFromCompressedBytes(inputStruct.PublicKey)
	if err != nil {
		log.Printf("Failed to parse public key: %v", err)
		return nil, remainingGas, fmt.Errorf("failed to parse public key: %w", err)
	}

	// Parse signature
	signature, err := bls.SignatureFromBytes(inputStruct.Signature)
	if err != nil {
		log.Printf("Failed to parse signature: %v", err)
		return nil, remainingGas, fmt.Errorf("failed to parse signature: %w", err)
	}

	// Verify signature
	isValid := bls.Verify(publicKey, signature, inputStruct.Message)
	log.Printf("Signature is valid: %v", isValid)

	// Encode result
	packedOutput, err := PackVerifySignatureOutput(isValid)
	if err != nil {
		log.Printf("Failed to pack output: %v", err)
		return nil, remainingGas, fmt.Errorf("failed to pack output: %w", err)
	}

	return packedOutput, remainingGas, nil
}

// Create the precompile contract and map the verifySignature function
func createBlsVerificationPrecompile() contract.StatefulPrecompiledContract {
	abiFunctionMap := map[string]contract.RunStatefulPrecompileFunc{
		"verifySignature": verifySignature,
	}

	var functions []*contract.StatefulPrecompileFunction
	for name, function := range abiFunctionMap {
		method, ok := BlsVerificationABI.Methods[name]
		if !ok {
			panic(fmt.Errorf("method (%s) not found in ABI", name))
		}
		functions = append(functions, contract.NewStatefulPrecompileFunction(method.ID, function))
	}

	statefulContract, err := contract.NewStatefulPrecompileContract(nil, functions)
	if err != nil {
		panic(fmt.Errorf("failed to create precompile contract: %w", err))
	}
	return statefulContract
}
